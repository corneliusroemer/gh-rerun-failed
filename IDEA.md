Automated GitHub Actions Rerunner Tool: Comprehensive Research and Technical Specification1. Executive Summary and Problem ContextThe modern software delivery lifecycle relies heavily on Continuous Integration (CI) and Continuous Deployment (CD) pipelines to maintain code quality and velocity. However, the reliability of these automated verification systems is frequently compromised by transient failures and non-deterministic test outcomes, commonly referred to as "flakiness." Research indicates that flaky tests can degrade developer productivity by up to 35%, eroding trust in the testing suite and forcing engineering teams to spend disproportionate amounts of time managing pipeline states rather than developing features.1In the GitHub Actions ecosystem, this friction is exacerbated by the lack of native tools for batch remediation. When a transient infrastructure failure—such as a package registry timeout or a runner disconnect—causes a cascade of failures across a feature branch or multiple Pull Requests (PRs), the remediation process is manually intensive. Maintainers must navigate to individual workflow run pages and trigger re-runs one by one. This report specifies the architecture and implementation of an Automated GitHub Actions Rerunner Tool, designed to bridge this operational gap.The proposed solution functions as a high-level command-line interface (CLI) extension, capable of interpreting Git context (commits, branches, PRs) and translating them into GitHub Actions API operations. By automating the detection and re-triggering of failed status checks, this tool aims to restore the "flow state" of development, ensuring that human attention is reserved for genuine code defects rather than infrastructure noise. This document serves as a comprehensive technical specification, detailing the market need, architectural decisions, API strategies, and implementation logic required to build a robust, enterprise-grade solution.2. Problem Space Analysis and User Needs2.1 The Operational Cost of Transient FailuresThe complexity of distributed systems implies that transient failures are inevitable. In a typical GitHub Actions workflow, dependencies on external services (Docker Hub, NPM, Maven Central) and internal resource contention on runners can lead to sporadic failures.2 These are failures where the code is correct, but the verification process failed.The cost of these failures is not merely the compute time wasted; it is the cognitive load placed on the developer. When a commit status turns red, a developer must context-switch from their IDE to the browser, navigate the GitHub UI, identify the failure type, and click "Re-run." While trivial in isolation, this action scales poorly. If a systemic outage causes failures across the last ten commits of a main branch, or if a merge queue is blocked by flaky checks on five different PRs, the manual remediation effort becomes a significant bottleneck.2.2 Inadequacies of Current ToolingCurrent mechanisms for handling these failures are fragmented and lack the "batch" context that maintainers require.Native GitHub UI:The GitHub web interface allows for re-running a specific workflow run or only its failed jobs.3 However, this interaction is strictly scoped to a single run. There is no "Select All Failed Runs on Branch" button. A maintainer wishing to clear a branch of transient failures must manually open every commit's status page.GitHub CLI (gh):The gh tool provides a programmatic interface to Actions via gh run rerun <RUN_ID>. While powerful, it operates on Run IDs, not Git objects. A developer thinks in terms of "Fix the build for commit a1b2c," but the CLI demands they first look up the Run ID associated with that commit.3 This disconnect necessitates complex, fragile shell one-liners to bridge the gap, often involving chained jq filters and xargs commands that are difficult to write and maintain.5Git Workarounds:A persistent workaround in the community is the "empty commit" pattern: git commit --allow-empty -m "trigger actions". This technique forces a new build by pushing a new Git object.7 While effective at triggering runs, it pollutes the git history with noise and, critically, triggers all workflows defined for the on: push event, not just the ones that failed. This results in unnecessary resource consumption and billing costs.2.3 Core Requirement DefinitionTo resolve these inefficiencies, the proposed tool must satisfy the following core requirements derived from the project specification:Abstraction of IDs: The user must be able to operate using high-level Git concepts (Commit SHA, Branch Name, PR Number) without needing to know specific Workflow Run IDs.Batch Processing: The tool must support "one-to-many" operations, such as re-running all failed checks for the last 24 hours of commits on a branch.Selective Remediation: It must target only failed or cancelled runs, avoiding redundant re-execution of successful or currently running jobs.9Efficiency: It should leverage the rerun-failed-jobs endpoint to retry only the specific failures within a workflow, preserving the artifacts and logs of successful steps.33. Prior Art and Market LandscapeBefore architectural design, it is essential to survey the existing landscape to ensure the proposed tool adds unique value and does not reinvent resolved problems. The search for prior art reveals a fragmented ecosystem of partial solutions.3.1 Scripting and CLI WorkaroundsThe most common "competitor" to a dedicated tool is the ad-hoc bash script. Community discussions on StackOverflow and GitHub issues demonstrate a recurring need to pipe the output of gh run list into gh run rerun.Example of Current Best Practice (Manual Scripting):Bashgh api repos/$OWNER/$REPO/commits/$SHA/check-runs | \
jq -r '.check_runs | select(.conclusion=="failure") |.id' | \
xargs -I {} gh run rerun {} --failed
While functional, these scripts are brittle.5 They often fail to handle pagination (missing runs if more than 30 exist), do not respect rate limits, and lack sophisticated filtering (e.g., distinguishing between a "cancelled" run that should be rerun and one cancelled intentionally). Furthermore, they require the user to have advanced knowledge of jq and the GitHub API schema.3.2 GitHub Actions Marketplace SolutionsSeveral Actions exist to handle retries within a workflow.Action / ToolScopeMechanismLimitationnick-fields/retryStep-LevelWraps a shell command in a retry loop.Only works for shell commands; cannot retry setup steps or dependent jobs.10actions/github-scriptWorkflow-LevelJavaScript executed within a step to trigger API calls.Requires modifying the YAML of every workflow; runs inside the failure context.6Flaky Test HandlersTest-LevelLanguage-specific runners (e.g., Maven Surefire) re-running failed tests.Does not address infrastructure failures (e.g., runner crash).2Analysis of Gap:These solutions operate inside the CI pipeline. If the pipeline itself crashes before reaching the retry step, or if the failure is at the infrastructure level, these tools fail. The proposed gh-rerunner operates outside the pipeline (from the developer's machine or a distinct dispatch event), allowing it to remediate failures that internal logic cannot catch.3.3 The "Missing Link" in ToolingThere is no dedicated, official CLI extension that aggregates these capabilities into a coherent "Batch Rerun" workflow. The existing gh extensions list and community forums discuss the need for better rerun management, confirming that while the primitive API endpoints exist, the orchestration layer is missing.6 This confirms the viability and necessity of the gh-rerunner project.4. Architectural Strategy and Implementation Vehicle4.1 Comparison of Implementation ModelsThree potential implementation vehicles were evaluated: a standalone CLI tool, a GitHub Action, and a GitHub CLI Extension.FeatureStandalone CLI ToolDedicated GitHub ActionGitHub CLI ExtensionAuthenticationRequires manual token management (PAT generation & storage).Uses GITHUB_TOKEN automatically.Inherits gh auth context; zero configuration.12DistributionBinary distribution (Homebrew, apt, etc.) required.Marketplace distribution; easy to use in CI.gh extension install; high discoverability.ContextUser's local machine.CI Runner environment.User's local machine (primary) & CI (via gh).UXDistinct syntax and learning curve.YAML configuration.Native feeling; integrates with existing gh workflow.Decision:The GitHub CLI Extension is the superior architectural choice. It eliminates the single biggest barrier to entry—authentication—by reusing the user's existing cached credentials. Furthermore, relying on the go-gh library provides robust, standardized wrappers for API interaction that respect GitHub's conventions.124.2 Programming Language and EcosystemLanguage Selection: GoWhile Bash is a common choice for simple extensions, the complexity of the required logic (JSON parsing, date math for time windows, concurrency management for batch operations) makes Bash fragile and difficult to maintain.13 Go is the native language of the GitHub CLI (gh) and offers the go-gh module, which provides strictly typed responses and automatic handling of the API's base URL and authentication headers.124.3 API Strategy: The Hybrid ApproachA critical architectural challenge identified in the research is the disconnect between "Commits" and "Workflow Runs" in the GitHub API.GraphQL API: Excellent for traversing the Git graph (e.g., "Get the last 50 commits on branch main"). It avoids the "N+1" query problem. However, the schema does not easily link a Commit object directly to a WorkflowRun object. It links to CheckSuites, but mapping a CheckSuite back to a generic WorkflowRun ID for the REST rerun endpoint is complex and sometimes unsupported for specific token scopes.14REST API: The endpoint GET /repos/{owner}/{repo}/actions/runs supports filtering by branch and sha.15 It is the definitive source for run_id, which is the required argument for the Rerun API.3Architecture Decision:The tool will employ a Hybrid Strategy:Discovery (REST): Use the REST API's filtering capabilities to find Workflow Runs. For example, to find failed runs on a branch, the tool will query actions/runs?branch=main&status=failure. This is more efficient than iterating commits in GraphQL because the API performs the filtering server-side.Context (GraphQL): Use GraphQL only when deep commit graph traversal is required (e.g., "Find the tips of all open PRs"). The GraphQL query will retrieve the headSHA of the PRs, which will then be fed into the REST discovery loop.Action (REST): The actual triggering of the rerun will exclusively use the REST endpoint POST /actions/runs/{run_id}/rerun-failed-jobs.95. Detailed Functional SpecificationThis section details the logic for the three core features, translating the requirements into executable algorithms.5.1 Core Component: The RunFinder EngineThe RunFinder is a shared logic module responsible for identifying the set of target WorkflowRun objects based on user input.Logic Flow:Input: A list of Git References (SHAs or Branch Names).Query: For each reference, query the actions/runs endpoint.Filter - Status: Discard any run where conclusion is success, neutral, or skipped. Keep failure, cancelled, timed_out.17Filter - Liveness: Discard any run where status is in_progress or queued. Attempting to rerun a running workflow is a logical error.Filter - Deduplication: If the same workflow (by workflow_id) has multiple runs for the same commit (re-attempts), select only the latest attempt. Rerunning an older attempt is usually redundant.5.2 Feature 1: Commit-Level RerunUser Story: "I broke the build on commit 8f2a1. I fixed the external dependency issue. I want to retry just that commit."Command: gh rerunner --commit <SHA>Implementation Details:The tool takes the SHA and calls GET /repos/{owner}/{repo}/actions/runs?head_sha=<SHA>.Edge Case: If the SHA is short (7 characters), the tool must use the Git command git rev-parse locally to resolve it to the full SHA, or rely on the API's ability to handle short SHAs (which is inconsistent). Resolving locally is safer.Output: A table displaying found failed runs.Confirmation: Prompt the user "Found 3 failed runs. Rerun? [y/N]".5.3 Feature 2: Branch-Level Batch RerunUser Story: "The develop branch has been flaky all night. I want to rerun everything from the last 24 hours to see what's actually broken."Command: gh rerunner --branch <name> --since 24hImplementation Logic:Time Calculation: Parse the duration 24h and subtract from time.Now() to get a created timestamp (e.g., 2023-10-27T10:00:00Z).API Filtering: Use the created query parameter in the REST API: GET /repos/{owner}/{repo}/actions/runs?branch=<name>&created=>2023-10-27T10:00:00Z&status=failure.18Insight: This single API call is vastly more efficient than iterating commits. It leverages the database index on the GitHub side.Pagination: The API returns 30 runs by default. The tool must loop through pages until no results remain.Batch Execution: The resulting list might contain 50+ runs. Triggering these sequentially is slow; triggering them all instantly risks secondary rate limits. The implementation must use a worker pool (concurrency limit ~5-10) to process the queue.5.4 Feature 3: Pull Request-Level RerunUser Story: "I have 10 open PRs that are blocked because of a npm outage. I need to rerun the checks on all of them."Command: gh rerunner --pr <number> or gh rerunner --all-open-prsImplementation Logic:Discovery (GraphQL):When --all-open-prs is set, fetching PR details via GraphQL is optimal to get the headRefOid (SHA) and headRefName (branch) for many PRs in a single request.GraphQLquery {
  repository(owner: "org", name: "repo") {
    pullRequests(first: 50, states: OPEN) {
      nodes {
        number
        headRefOid
        isDraft
      }
    }
  }
}
Filtering:Drafts: Draft PRs often have failing checks intentionally (WIP). The tool should offer a flag --include-drafts but default to excluding them.Mapping:For each identified headRefOid, execute the Commit-Level Rerun logic.Merge Queues:If a PR is in a Merge Queue, the relevant commit is not the PR head, but the temporary merge commit created by the queue. This is a complex edge case. The tool should detect if a PR is in a queue (via GraphQL mergeQueueEntry) and warn the user that manual intervention might be required, or attempt to find the specific temporary branch associated with the queue group.196. Technical Implementation SpecificationThis section provides the low-level engineering details required for developers to build the tool.6.1 Data Structures (Go)Gopackage main

import "time"

// RerunOptions defines the user's intent.
type RerunOptions struct {
    CommitSHA   string
    Branch      string
    PRNumber    int
    AllOpenPRs  bool
    Since       time.Duration
    FailedOnly  bool // If true, uses /rerun-failed-jobs (Default). If false, /rerun (All jobs).
    DryRun      bool
}

// WorkflowRun represents the subset of fields we need from the REST API.
type WorkflowRun struct {
    ID         int64     `json:"id"`
    Name       string    `json:"name"`
    HeadBranch string    `json:"head_branch"`
    HeadSha    string    `json:"head_sha"`
    Conclusion string    `json:"conclusion"` // failure, cancelled, timed_out
    Status     string    `json:"status"`     // completed, in_progress, queued
    CreatedAt  time.Time `json:"created_at"`
}
6.2 The Rerun Execution LoopThe execution logic must handle the "Tri-State" of a rerun: Success, Failure (API Error), and Failure (Rate Limit).Go// Pseudo-code for the execution engine

func ExecuteReruns(runsWorkflowRun, opts RerunOptions) {
    // Semaphore to limit concurrency to 5 active requests
    sem := make(chan struct{}, 5)
    
    for _, run := range runs {
        // Acquire token
        sem <- struct{}{}
        
        go func(r WorkflowRun) {
            defer func() { <-sem }() // Release token
            
            if opts.DryRun {
                fmt.Printf(" Would rerun workflow %d: %s\n", r.ID, r.Name)
                return
            }
            
            endpoint := fmt.Sprintf("repos/%s/%s/actions/runs/%d/rerun-failed-jobs", owner, repo, r.ID)
            if!opts.FailedOnly {
                endpoint = fmt.Sprintf("repos/%s/%s/actions/runs/%d/rerun", owner, repo, r.ID)
            }
            
            err := client.Post(endpoint, nil)
            if err!= nil {
                handleError(err) // Check for 403 Rate Limit
            } else {
                fmt.Printf("✓ Triggered rerun for %s\n", r.Name)
            }
        }(run)
    }
}
6.3 Handling Rate LimitsRate limiting is the primary technical risk for a batch tool. GitHub enforces two types of limits:Primary Rate Limit: 5,000 requests per hour for authenticated users (15,000 for Enterprise).20Analysis: A batch run on 50 PRs might generate ~100 requests (50 lists + 50 reruns). This is well within the primary limit.Secondary Rate Limit: Limits on concurrent requests and CPU usage. This is often triggered by "bursty" behavior.21Mitigation: The tool must implement a client-side throttle. The semaphore pattern shown in 6.2 (limit 5) is mandatory. Additionally, if the API returns a 403 or 429, the client must inspect the Retry-After header and block all worker threads until that duration passes.226.4 Configuration and StateThe tool should support a configuration file (.gh-rerunner.yaml) or environment variables for team-wide defaults.Configuration Parameters:default_branch: Defaults to main or master if not detected.ignore_workflows: A list of workflow names (e.g., "Linting") that should never be automatically rerun, perhaps because they are deterministic and a failure always implies a code error.failed_only_default: Boolean to set the default behavior of the tool.7. Operational Considerations and Future Outlook7.1 Security and PermissionsThe tool operates under the permissions of the user's active GitHub token.Scope Requirements: The token needs repo scope (to read runs) and workflow scope (to trigger reruns).3Validation: On startup, the tool should validate scopes. If workflow scope is missing, the API call to rerun will fail with 403. The tool should proactively check the token scopes via gh auth status (or the API equivalent) and guide the user to run gh auth refresh -s workflow if necessary.7.2 Integration with CI/CD PipelinesWhile designed as a CLI for humans, this tool can also be run inside a GitHub Action to create a "Self-Healing" pipeline.Scenario: A nightly cron job runs gh rerunner --branch main --since 24h to clean up any transient failures that occurred during the day.Authentication: In this context, the GITHUB_TOKEN is used. The rate limit for GITHUB_TOKEN is lower (1,000 requests/hour).21 The tool's efficiency (using filtered REST queries) becomes even more critical here to prevent exhausting the repository's token limit.7.3 Future Enhancements: AI-Driven AnalysisThe current specification focuses on status-based reruns. A future iteration could implement log-based intelligence.Concept: Before rerunning, fetch the failure logs (gh run view <id> --log).Analysis: Search for keywords like "timeout," "503 Service Unavailable," or "Connection Reset."Decision: Only rerun if these transient keywords are found. If the log contains "SyntaxError" or "Test Failed: Assertion Error," skip the rerun, as it is likely a legitimate code defect. This would significantly reduce resource waste (Action Minutes).8. ConclusionThe gap between Git operations (commits/branches) and CI operations (runs/jobs) creates significant friction in the developer workflow. The Automated GitHub Actions Rerunner Tool specified here bridges this gap. By combining the discoverability of the gh CLI ecosystem with a robust, hybrid API strategy, the tool provides a safe, efficient, and user-centric method for managing pipeline stability.The architectural decision to build this as a Go-based extension ensures maintainability and alignment with GitHub's own tooling standards. The detailed filtering logic and rate-limit handling mechanisms specified ensure that the tool can scale to handle the demands of large enterprise repositories without disrupting the underlying platform. This specification provides a complete blueprint for the implementation phase, addressing the immediate need for batch remediation while laying the groundwork for future intelligent features.9. Appendix: Data Tables and Reference Material9.1 API Endpoint Usage ReferenceOperationMethodEndpoint PatternPurposeList Runs (Commit)GET/repos/{o}/{r}/actions/runs?head_sha={sha}Finding runs for a specific commit.List Runs (Branch)GET/repos/{o}/{r}/actions/runs?branch={b}&created=>{t}finding batch runs on a branch history.Rerun RunPOST/repos/{o}/{r}/actions/runs/{id}/rerunRerunning an entire workflow.Rerun FailedPOST/repos/{o}/{r}/actions/runs/{id}/rerun-failed-jobsRerunning only failed jobs (optimized).Get PRsGraphQLquery { repository { pullRequests... } }Efficiently fetching tips of open PRs.9.2 Rate Limit Consumption EstimatesThe following table estimates the API cost for common operations using this tool.Operation ScenarioAPI Calls (Est.)Token Cost (Points)NotesSingle Commit Rerun2 (1 List + 1 Post)~2Negligible impact.Branch Scan (24h, 50 runs)2 (1 Filtered List + 1 Post Loop)~52List is 1 call; Post is 1 per run.All Open PRs (20 PRs)21 (1 GraphQL + 20 Lists + Reruns)~40-60GraphQL saves 19 "Get PR" calls.This efficiency analysis confirms that the proposed architecture is viable even for teams with high-velocity commit rates.
